# This file was *autogenerated* from the file printTables.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_1 = Integer(1); _sage_const_10 = Integer(10); _sage_const_0 = Integer(0)
import optparse
import quadrature
import interpolateBasisFunctions as interp

def main():

    parser = optparse.OptionParser()
    parser.add_option("-o", "--order",
        help="""Order of Lagrangian interpolant""", metavar="ORDER")
    parser.add_option("-d", "--derivative",
        help="""set to 1 to calculate gradients, 0 for basis functions""",
        metavar="DERIVATIVE")

    (options, args) = parser.parse_args()
    order_flag      = int(options.order)
    derivative_flag = int(options.derivative)

    # verify command line arguements.
    if order_flag not in (ellipsis_range(_sage_const_1 ,Ellipsis,_sage_const_10 )):
        raise AttributeError("GMSH only supports orders 1 through 10.")
    if derivative_flag not in (ellipsis_range(_sage_const_0 ,Ellipsis,_sage_const_1 )):
        raise AttributeError("""This program can only return either the basis
            functions or their gradients.""")

    # run the program.
    var('x, y')
    points = quadrature.points[order_flag]
    polynomial_list = interp.interpolate_basis_polynomials(order_flag)
    if derivative_flag == _sage_const_1 : # use gradients
        print [map(f, points)
               for f in map(gradient_to_function, map(gradient, polynomial_list))]
    else: # use basis functions
        print [map(f, points) for f in map(polynomial_to_function, polynomial_list)]

def gradient(f):
    """Calculate the gradient of some symbolic expression. Return it as a pair."""
    var('x,y')
    return [f.diff(x), f.diff(y)]

def gradient_to_function(f):
    """Convert some gradient into a function mapping a pair of doubles to a
    pair of doubles."""
    return (lambda coords : [f[_sage_const_0 ].subs({x : coords[_sage_const_0 ], y : coords[_sage_const_1 ]}),
                            f[_sage_const_1 ].subs({x : coords[_sage_const_0 ], y : coords[_sage_const_1 ]})])

def polynomial_to_function(f):
    """Convert some symbolic polynomial into a function mapping a pair of
    doubles to a pair of doubles."""
    return (lambda coords : f.subs({x : coords[_sage_const_0 ], y : coords[_sage_const_1 ]}))

if __name__ == '__main__':
    main()
