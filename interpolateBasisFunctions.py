# This file was *autogenerated* from the file interpolateBasisFunctions.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_10 = Integer(10); _sage_const_0 = Integer(0)
import optparse

def main():

    parser = optparse.OptionParser()
    parser.add_option("-o", "--order",
    help="""Order of Lagrangian interpolant""", metavar="ORDER")

    (options, args) = parser.parse_args()
    order = int(options.order)

    if order in (ellipsis_range(_sage_const_1 ,Ellipsis,_sage_const_10 )):
        print format_basis_polynomials(int(options.order))
    else:
        raise AttributeError("GMSH only supports orders 1 through 10.")

def sum_until(n):
    """Sum the integers up to n."""
    return (n + _sage_const_1 )*n/_sage_const_2 

def build_all_RHS(order):
    """Construct all the RHS vectors (that is, the values of the polynomial
    evaluated at the nodes)."""

    def build_RHS(nonzero_node, order=_sage_const_2 ):
        """Construct some RHS vector [1,0,0,...,0] given the position of the
        1 and order of the approximating polynomials."""

        RHS = [[_sage_const_0 ] for n in (ellipsis_range(_sage_const_0 ,Ellipsis,sum_until(order + _sage_const_1 )-_sage_const_1 ))]
        RHS[nonzero_node] = [_sage_const_1 ]
        return matrix(RHS)

    number_of_nodes = sum_until(order + _sage_const_1 )
    return ([build_RHS(nonzero_node, order) for nonzero_node in
            (ellipsis_range(_sage_const_0  ,Ellipsis, (number_of_nodes - _sage_const_1 )))])

def build_coefficient_matrix(order=_sage_const_2 ):
    """Given an order, build a coefficient matrix."""

    # calculate the big list of symbols. Looks like 1,x,y,x^2,xy,y^2,x^3,x^2y..
    var('x,y')
    polynomial_powers = [x**(n-m)*y**m for n in (ellipsis_range(_sage_const_0 ,Ellipsis,order)) for m in (ellipsis_range(_sage_const_0 ,Ellipsis,n))]

    node_coordinates = build_node_list(order)

    # create a list of lists; each component list is polynomial_powers
    # evaluated at a node.
    vandermonde_lists = ([map(lambda n : n.subs(x=node[_sage_const_0 ], y=node[_sage_const_1 ]),
        polynomial_powers) for node in node_coordinates])

    # return the symbolic matrix representation.
    return matrix(vandermonde_lists)

def build_node_list(order):

    # interior function for labeling the nodes on the edges of a triangle.
    def label_triangle(corner0, corner1, corner2, order):
        """Given locations of corners label the nodes on the sides of a
        triangle."""

        step_towards_center = (corner1[_sage_const_0 ] - corner0[_sage_const_0 ])/order
        edge_node_coordinates = ([corner0, corner1, corner2] +

        # add coordinates along x-axis.
        [(corner0[_sage_const_0 ] + x,corner0[_sage_const_1 ]) for x in [n*step_towards_center
            for n in (ellipsis_range(_sage_const_1 ,Ellipsis,(order-_sage_const_1 )))]] +
        # add coordinates along the line parallel to y = 1 - x.
        [(corner2[_sage_const_1 ] - x, corner0[_sage_const_1 ] + x) for x in [n*step_towards_center
            for n in (ellipsis_range(_sage_const_1 ,Ellipsis,(order-_sage_const_1 )))]] +
        # add coordinates along y-axis.
        [(corner0[_sage_const_0 ],corner0[_sage_const_1 ] + y) for y in [n*step_towards_center
            for n in reversed((ellipsis_range(_sage_const_1 ,Ellipsis,order-_sage_const_1 )))]])

        return edge_node_coordinates

    # interior function for recursion.
    def construct_nodes(corner0, corner1, corner2, order):
        """Recursively build the list of node coordinates. Order the nodes as GMSH
        does."""

        # check if all the corners are the same; if so, return one item.
        if corner0 == corner1 == corner2:

            return [corner0]

        else:

            # get the outer node coordinates.
            node_coordinates = label_triangle(corner0, corner1, corner2, order)

            # find the nodes for the inner triangle. If they are all equal we
            # are done. Otherwise recur.
            if order > _sage_const_2 : # If order <= 2 then there are no interior nodes.

                step_towards_center = (corner1[_sage_const_0 ] - corner0[_sage_const_0 ])/order
                new_corner0 = (corner0[_sage_const_0 ] + step_towards_center, corner0[_sage_const_1 ] +
                        step_towards_center)
                new_corner1 = (corner1[_sage_const_0 ] - _sage_const_2 *step_towards_center, corner1[_sage_const_1 ] +
                        step_towards_center)
                new_corner2 = (corner2[_sage_const_0 ] + step_towards_center, corner2[_sage_const_1 ] -
                        _sage_const_2 *step_towards_center)
                return node_coordinates + construct_nodes(new_corner0,
                    new_corner1, new_corner2, order - _sage_const_3 )

            else:

                return node_coordinates

    # call the recurring function with the proper first three corners.
    return construct_nodes((_sage_const_0 ,_sage_const_0 ),(_sage_const_1 ,_sage_const_0 ),(_sage_const_0 ,_sage_const_1 ),order)

def interpolate_basis_polynomials(order):
    """Given some order, interpolate the basis polynomials. Number the interior
    nodes used as GMSH does (recursively)."""

    A_inverse = build_coefficient_matrix(order).inverse()
    return [A_inverse * RHS for RHS in build_all_RHS(order)]

def format_basis_polynomials(order):
    """Given some order, interpolate the basis polynomials and return their
    representation as a string that the FEMBasis program can understand."""

    coefficients = interpolate_basis_polynomials(order)
    powers       = [(n-m,m,_sage_const_0 ) for n in (ellipsis_range(_sage_const_0 ,Ellipsis,order)) for m in (ellipsis_range(_sage_const_0 ,Ellipsis,n))]

    flatten_inner_tupples = (lambda x :
        map(lambda y : (float(y[_sage_const_0 ][_sage_const_0 ]), y[_sage_const_1 ][_sage_const_0 ], y[_sage_const_1 ][_sage_const_1 ], y[_sage_const_1 ][_sage_const_2 ]), x))
    # Build a list of polynomials in the export format.
    return (map(flatten_inner_tupples,
       [zip(x, powers) for x in interpolate_basis_polynomials(order)]))

if __name__ == '__main__':
    main()
