# This file was *autogenerated* from the file interpolateBasisFunctions.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_10 = Integer(10); _sage_const_0 = Integer(0)
import optparse
import quadrature

def main():

    parser = optparse.OptionParser()
    parser.add_option("-o", "--order",
        help="""Order of Lagrangian interpolant""", metavar="ORDER")
    parser.add_option("-d", "--derivative",
        help="""set to 1 to calculate gradients, 0 for basis functions""",
        metavar="DERIVATIVE")

    (options, args) = parser.parse_args()
    order_flag      = int(options.order)
    derivative_flag = int(options.derivative)

    # verify command line arguements.
    if order_flag not in (ellipsis_range(_sage_const_1 ,Ellipsis,_sage_const_10 )):
        raise AttributeError("GMSH only supports orders 1 through 10.")
    if derivative_flag not in (ellipsis_range(_sage_const_0 ,Ellipsis,_sage_const_1 )):
        raise AttributeError("""This program can only return either the basis
            functions or their gradients.""")

    # run the program.
    points = quadrature.points[order_flag]
    polynomial_list = interpolate_basis_polynomials(order_flag)
    if derivative_flag == _sage_const_1 : # use gradients
        print [map(f, points)
               for f in map(gradient_to_function, map(gradient, polynomial_list))]
    else: # use basis functions
        print [map(f, points) for f in map(polynomial_to_function, polynomial_list)]

def sum_until(n):
    """Sum the integers up to n."""
    return (n + _sage_const_1 )*n/_sage_const_2 

def build_all_RHS(order):
    """Construct all the RHS vectors (that is, the values of the polynomial
    evaluated at the nodes)."""

    def build_RHS(nonzero_node, order=_sage_const_2 ):
        """Construct some RHS vector [1,0,0,...,0] given the position of the
        1 and order of the approximating polynomials."""

        RHS = [[_sage_const_0 ] for n in (ellipsis_range(_sage_const_0 ,Ellipsis,sum_until(order + _sage_const_1 )-_sage_const_1 ))]
        RHS[nonzero_node] = [_sage_const_1 ]
        return matrix(RHS)

    number_of_nodes = sum_until(order + _sage_const_1 )
    return ([build_RHS(nonzero_node, order) for nonzero_node in
            (ellipsis_range(_sage_const_0  ,Ellipsis, (number_of_nodes - _sage_const_1 )))])

def build_coefficient_matrix(order=_sage_const_2 ):
    """Given an order, build a coefficient matrix."""

    # calculate the big list of symbols. Looks like 1,x,y,x^2,xy,y^2,x^3,x^2y..
    var('x,y')
    polynomial_powers = [x**(n-m)*y**m for n in (ellipsis_range(_sage_const_0 ,Ellipsis,order)) for m in (ellipsis_range(_sage_const_0 ,Ellipsis,n))]

    node_coordinates = build_node_list(order)

    # create a list of lists; each component list is polynomial_powers
    # evaluated at a node.
    vandermonde_lists = ([map(lambda n : n.subs(x=node[_sage_const_0 ], y=node[_sage_const_1 ]),
        polynomial_powers) for node in node_coordinates])

    # return the symbolic matrix representation.
    return matrix(vandermonde_lists)

def build_node_list(order):

    # interior function for labeling the nodes on the edges of a triangle.
    def label_triangle(corner0, corner1, corner2, order):
        """Given locations of corners label the nodes on the sides of a
        triangle."""

        step_towards_center = (corner1[_sage_const_0 ] - corner0[_sage_const_0 ])/order
        edge_node_coordinates = ([corner0, corner1, corner2] +

        # add coordinates along x-axis.
        [(corner0[_sage_const_0 ] + x,corner0[_sage_const_1 ]) for x in [n*step_towards_center
            for n in (ellipsis_range(_sage_const_1 ,Ellipsis,(order-_sage_const_1 )))]] +
        # add coordinates along the line parallel to y = 1 - x.
        [(corner2[_sage_const_1 ] - x, corner0[_sage_const_1 ] + x) for x in [n*step_towards_center
            for n in (ellipsis_range(_sage_const_1 ,Ellipsis,(order-_sage_const_1 )))]] +
        # add coordinates along y-axis.
        [(corner0[_sage_const_0 ],corner0[_sage_const_1 ] + y) for y in [n*step_towards_center
            for n in reversed((ellipsis_range(_sage_const_1 ,Ellipsis,order-_sage_const_1 )))]])

        return edge_node_coordinates

    # interior function for recursion.
    def construct_nodes(corner0, corner1, corner2, order):
        """Recursively build the list of node coordinates. Order the nodes as GMSH
        does."""

        # check if all the corners are the same; if so, return one item.
        if corner0 == corner1 == corner2:

            return [corner0]

        else:

            # get the outer node coordinates.
            node_coordinates = label_triangle(corner0, corner1, corner2, order)

            # find the nodes for the inner triangle. If they are all equal we
            # are done. Otherwise recur.
            if order > _sage_const_2 : # If order <= 2 then there are no interior nodes.

                step_towards_center = (corner1[_sage_const_0 ] - corner0[_sage_const_0 ])/order
                new_corner0 = (corner0[_sage_const_0 ] + step_towards_center, corner0[_sage_const_1 ] +
                        step_towards_center)
                new_corner1 = (corner1[_sage_const_0 ] - _sage_const_2 *step_towards_center, corner1[_sage_const_1 ] +
                        step_towards_center)
                new_corner2 = (corner2[_sage_const_0 ] + step_towards_center, corner2[_sage_const_1 ] -
                        _sage_const_2 *step_towards_center)
                return node_coordinates + construct_nodes(new_corner0,
                    new_corner1, new_corner2, order - _sage_const_3 )

            else:

                return node_coordinates

    # call the recurring function with the proper first three corners.
    return construct_nodes((_sage_const_0 ,_sage_const_0 ),(_sage_const_1 ,_sage_const_0 ),(_sage_const_0 ,_sage_const_1 ),order)

def tripple_form_to_symbolic(tripplet_list):
    """convert a list of tripplets into a symbolic polynomial using xs and
    ys."""

    var('x,y')
    return sum(map(lambda tripplet :
               tripplet[_sage_const_0 ] * x**tripplet[_sage_const_1 ] * y**tripplet[_sage_const_2 ], tripplet_list))

def interpolate_basis_polynomials(order):
    """Given some order, interpolate the basis polynomials and return them as
    symbolic statements. The arguement to the function is something with two
    indexes. Number the interior nodes used as GMSH does (recursively)."""

    A_inverse = build_coefficient_matrix(order).inverse()

    coefficients = [A_inverse * RHS for RHS in build_all_RHS(order)]
    powers       = [(n-m,m,_sage_const_0 ) for n in (ellipsis_range(_sage_const_0 ,Ellipsis,order)) for m in (ellipsis_range(_sage_const_0 ,Ellipsis,n))]

    flatten_inner_tupples = (lambda x :
        map(lambda y : (float(y[_sage_const_0 ][_sage_const_0 ]), y[_sage_const_1 ][_sage_const_0 ], y[_sage_const_1 ][_sage_const_1 ], y[_sage_const_1 ][_sage_const_2 ]), x))

    # convert to tripples, then convert to functions.
    tripple_form = (map(flatten_inner_tupples,
       [zip(x, powers) for x in coefficients]))

    return map(tripple_form_to_symbolic, tripple_form)

def gradient(f):
    """Calculate the gradient of some symbolic expression. Return it as a pair."""
    var('x,y')
    return [f.diff(x), f.diff(y)]

def gradient_to_function(f):
    """Convert some gradient into a function mapping a pair of doubles to a
    pair of doubles."""
    return (lambda coords : [f[_sage_const_0 ].subs({x : coords[_sage_const_0 ], y : coords[_sage_const_1 ]}),
                            f[_sage_const_1 ].subs({x : coords[_sage_const_0 ], y : coords[_sage_const_1 ]})])

def polynomial_to_function(f):
    """Convert some symbolic polynomial into a function mapping a pair of
    doubles to a pair of doubles."""
    return (lambda coords : f.subs({x : coords[_sage_const_0 ], y : coords[_sage_const_1 ]}))

if __name__ == '__main__':
    main()
